---
title: Enums
description: Creating enum-like types in Go using const and iota
---

## Go Does Not Have Enums

Unlike languages such as Java, C#, or TypeScript, Go does not have a built-in `enum` keyword. Instead, Go provides patterns using **constants** and **iota** that achieve similar functionality with more flexibility.

---

## Basic Enum Pattern

Create a custom type and define constants of that type:

```go
type Status int

const (
    Pending Status = iota  // 0
    Active                 // 1
    Completed              // 2
    Cancelled              // 3
)

func main() {
    var orderStatus Status = Active
    fmt.Println(orderStatus)  // 1
}
```

---

## Simple String Enums

For cases where you want human-readable string values without conversion, define constants with a string type:

```go
type Status string

const (
    Pending Status = "pending"
    Active  Status = "active"
    Done    Status = "done"
)

func main() {
    status := Active
    fmt.Println(status)  // active (already a string)
}
```

### Advantages of String Enums

- No `String()` method needed for readable output
- JSON marshaling works automatically with the string value
- Database storage is self-documenting
- Easy to compare with string literals if needed

```go
type OrderStatus string

const (
    OrderPending   OrderStatus = "pending"
    OrderShipped   OrderStatus = "shipped"
    OrderDelivered OrderStatus = "delivered"
)

type Order struct {
    ID     int         `json:"id"`
    Status OrderStatus `json:"status"`
}

func main() {
    order := Order{ID: 1, Status: OrderShipped}
    
    data, _ := json.Marshal(order)
    fmt.Println(string(data))
    // {"id":1,"status":"shipped"}
}
```

### When to Use String vs Integer Enums

| Use String Enums When | Use Integer Enums (iota) When |
|-----------------------|-------------------------------|
| Values appear in JSON/APIs | Performance is critical |
| Stored in databases as text | Need bitwise operations (flags) |
| Human readability matters | Sequential numbering is useful |
| Debugging is easier with strings | Memory efficiency matters |

### Why the Custom Type is Required

Understanding why Go requires `type Status string` instead of just using constants reveals something fundamental about Go's type system.

**First attempt: plain constants**

```go
const (
    Pending = "pending"
    Running = "running"
)
```

This looks like an enum, but it is not. These are just string constants. Anywhere a string is accepted, these work, but so does `"banana"`. The compiler has no concept that `"banana"` is invalid in your mental model.

**Second attempt: explicitly typed as string**

```go
const (
    Pending string = "pending"
    Running string = "running"
)
```

This feels stronger because you explicitly wrote `string`. But this changes nothing.

Writing `string` here does not create a new type. You are simply telling the compiler these constants are of the already-existing built-in type `string`. They remain just strings. They still accept `"banana"`. No constraints were added.

**The distinction: values vs types**

Constants live in the value world, not the type world. A constant declaration creates a named value, but it cannot create a new type. Only a type declaration can do that.

**The solution: define a new type**

```go
type Status string
```

This single line changes everything.

This does not mean "Status is a string." It means: "Create a new type called Status whose underlying representation is a string."

Same bytes at runtime. Different identity at compile time.

Now when you write:

```go
const (
    Pending Status = "pending"
    Running Status = "running"
)

func SetStatus(s Status) {}
```

The function `SetStatus` accepts `Pending` but rejects `"pending"`. Go is enforcing meaning through types.

### Const Blocks Do Not Propagate Types

A common misconception:

```go
const (
    Pending Status = "pending"
    Running = "running"  // What type is this?
)
```

This compiles, but it creates two different things:

- `Pending` is a typed constant of type `Status`
- `Running` is an untyped string constant

Go does not propagate types inside a const block. Each constant is evaluated independently. A const block is grouping for convenience, not a shared type context.

So `Running` is not a `Status`, even though it sits next to one. You must explicitly type each constant:

```go
const (
    Pending Status = "pending"
    Running Status = "running"  // Explicit type required
)
```

Go never guesses intent. If you want a value to be a `Status`, you must say so.

---

### How iota Works

`iota` is a special constant that starts at `0` and increments by `1` for each constant in the block:

```go
const (
    A = iota  // 0
    B         // 1
    C         // 2
    D         // 3
)
```

Each new `const` block resets `iota` to `0`:

```go
const (
    First = iota  // 0
    Second        // 1
)

const (
    Another = iota  // 0 (reset)
)
```

---

## Type Safety with Custom Types

Using a custom type prevents accidental mixing of unrelated values:

```go
type Day int
type Month int

const (
    Monday Day = iota
    Tuesday
    Wednesday
)

const (
    January Month = iota + 1  // Start at 1
    February
    March
)

func PrintDay(d Day) {
    fmt.Println("Day:", d)
}

func main() {
    PrintDay(Monday)    // Works
    // PrintDay(January) // Compile error: cannot use January (type Month) as type Day
}
```

---

## Starting from a Different Value

You can start the sequence at any value:

```go
const (
    StatusOK       = iota + 200  // 200
    StatusCreated                // 201
    StatusAccepted               // 202
)
```

Or skip values:

```go
const (
    _        = iota  // 0 (skipped with blank identifier)
    KB int64 = 1 << (10 * iota)  // 1 << 10 = 1024
    MB                           // 1 << 20 = 1,048,576
    GB                           // 1 << 30
    TB                           // 1 << 40
)
```

---

## String Representations

Enums print as numbers by default. Add a `String()` method for readable output:

```go
type Status int

const (
    Pending Status = iota
    Active
    Completed
    Cancelled
)

func (s Status) String() string {
    switch s {
    case Pending:
        return "Pending"
    case Active:
        return "Active"
    case Completed:
        return "Completed"
    case Cancelled:
        return "Cancelled"
    default:
        return "Unknown"
    }
}

func main() {
    status := Active
    fmt.Println(status)  // Active (not 1)
}
```

### Using a Slice for Strings

For simple cases, a slice lookup is cleaner:

```go
type Status int

const (
    Pending Status = iota
    Active
    Completed
    Cancelled
)

var statusNames = []string{"Pending", "Active", "Completed", "Cancelled"}

func (s Status) String() string {
    if int(s) < len(statusNames) {
        return statusNames[s]
    }
    return "Unknown"
}
```

---

## Validation

Check if a value is within the valid range:

```go
type Size int

const (
    Small Size = iota
    Medium
    Large
    sizeCount  // unexported, used for validation
)

func (s Size) IsValid() bool {
    return s >= Small && s < sizeCount
}

func main() {
    size := Size(10)
    fmt.Println(size.IsValid())  // false
    
    size = Medium
    fmt.Println(size.IsValid())  // true
}
```

---

## Bitwise Flags with iota

Use bit shifting for flags that can be combined:

```go
type Permission int

const (
    Read Permission = 1 << iota  // 1
    Write                        // 2
    Execute                      // 4
)

func main() {
    // Combine permissions with OR
    userPerms := Read | Write

    // Check permissions with AND
    if userPerms&Read != 0 {
        fmt.Println("Has read permission")
    }
    if userPerms&Execute != 0 {
        fmt.Println("Has execute permission")
    } else {
        fmt.Println("No execute permission")
    }
}
```

### Checking Multiple Flags

```go
func (p Permission) Has(flag Permission) bool {
    return p&flag != 0
}

func (p Permission) String() string {
    var perms []string
    if p.Has(Read) {
        perms = append(perms, "Read")
    }
    if p.Has(Write) {
        perms = append(perms, "Write")
    }
    if p.Has(Execute) {
        perms = append(perms, "Execute")
    }
    return strings.Join(perms, "|")
}

func main() {
    perms := Read | Execute
    fmt.Println(perms)  // Read|Execute
}
```

---

## Parsing Strings to Enums

To convert strings back to enum values:

```go
type Status int

const (
    Pending Status = iota
    Active
    Completed
    Cancelled
)

func ParseStatus(s string) (Status, error) {
    switch strings.ToLower(s) {
    case "pending":
        return Pending, nil
    case "active":
        return Active, nil
    case "completed":
        return Completed, nil
    case "cancelled":
        return Cancelled, nil
    default:
        return 0, fmt.Errorf("unknown status: %s", s)
    }
}
```

### Using a Map for Parsing

```go
var statusMap = map[string]Status{
    "pending":   Pending,
    "active":    Active,
    "completed": Completed,
    "cancelled": Cancelled,
}

func ParseStatus(s string) (Status, bool) {
    status, ok := statusMap[strings.ToLower(s)]
    return status, ok
}
```

---

## Complete Enum Example

```go
package main

import (
    "fmt"
    "strings"
)

type OrderStatus int

const (
    OrderPending OrderStatus = iota
    OrderProcessing
    OrderShipped
    OrderDelivered
    OrderCancelled
)

var orderStatusNames = []string{
    "Pending",
    "Processing",
    "Shipped",
    "Delivered",
    "Cancelled",
}

var orderStatusMap = map[string]OrderStatus{
    "pending":    OrderPending,
    "processing": OrderProcessing,
    "shipped":    OrderShipped,
    "delivered":  OrderDelivered,
    "cancelled":  OrderCancelled,
}

func (s OrderStatus) String() string {
    if int(s) < len(orderStatusNames) {
        return orderStatusNames[s]
    }
    return "Unknown"
}

func ParseOrderStatus(s string) (OrderStatus, bool) {
    status, ok := orderStatusMap[strings.ToLower(s)]
    return status, ok
}

func (s OrderStatus) IsTerminal() bool {
    return s == OrderDelivered || s == OrderCancelled
}

func main() {
    status := OrderShipped
    fmt.Printf("Status: %s (%d)\n", status, status)
    fmt.Printf("Is terminal: %v\n", status.IsTerminal())

    parsed, ok := ParseOrderStatus("delivered")
    if ok {
        fmt.Printf("Parsed: %s\n", parsed)
    }
}
```

Output:
```
Status: Shipped (2)
Is terminal: false
Parsed: Delivered
```

---

## Key Points

1. Go uses `const` blocks with `iota` instead of a dedicated enum keyword
2. Create a custom type for type safety
3. `iota` resets to 0 in each new const block
4. Add a `String()` method for readable output
5. Use bit shifting (`1 << iota`) for combinable flags
6. Always handle unknown/invalid values in String and Parse methods
