---
title: Option Type
description: Handling the absence of values with Option instead of null
---

Rust uses `Option` instead of null to represent the absence of a value.

## The Option Enum

```rust
enum Option<T> {
    Some(T),  // Value exists
    None,     // No value
}
```

## Using Option

```rust
fn main() {
    let some_number: Option<i32> = Some(5);
    let no_number: Option<i32> = None;

    // Must handle both cases
    match some_number {
        Some(n) => println!("Number: {}", n),
        None => println!("No number"),
    }
}
```

## Practical Example

```rust
fn find_first_a(s: &str) -> Option<usize> {
    for (i, ch) in s.chars().enumerate() {
        if ch == 'a' {
            return Some(i);
        }
    }
    None
}

fn main() {
    let result = find_first_a("Shubham");

    match result {
        Some(index) => println!("First 'a' at index {}", index),
        None => println!("No 'a' found"),
    }

    // Using if let
    if let Some(index) = find_first_a("hello") {
        println!("Found at {}", index);
    }
}
```

## Option Methods

```rust
fn main() {
    let x: Option<i32> = Some(5);

    // unwrap: panics if None
    let value = x.unwrap();

    // unwrap_or: default if None
    let value = x.unwrap_or(0);

    // unwrap_or_else: compute default lazily
    let value = x.unwrap_or_else(|| compute_default());

    // map: transform the value if Some
    let doubled: Option<i32> = x.map(|n| n * 2);

    // and_then: chain operations
    let result: Option<i32> = x.and_then(|n| Some(n * 2));

    // is_some / is_none
    if x.is_some() {
        println!("Has value");
    }
}
```

## Common Methods Summary

| Method | Returns | On None |
|--------|---------|---------|
| `unwrap()` | T | Panics |
| `unwrap_or(default)` | T | Returns default |
| `unwrap_or_else(f)` | T | Calls f() |
| `map(f)` | Option<U> | Returns None |
| `and_then(f)` | Option<U> | Returns None |
| `is_some()` | bool | false |
| `is_none()` | bool | true |
