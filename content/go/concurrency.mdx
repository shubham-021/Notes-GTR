---
title: Concurrency
description: Goroutines, WaitGroups, and Go's approach to concurrent programming
---

# Concurrency

## Go Routines

A goroutine is a lightweight thread managed by the Go runtime. Start one with the `go` keyword:

```go
go someFunction()
```

## The Problem: Main Thread Doesn't Wait

The main thread doesn't wait for other goroutines to complete. It terminates as soon as it finishes its own work:

```go
func main() {
    go sendEmail()  // Starts but might not finish
    fmt.Println("Main done")
}  // Program exits, sendEmail might be killed
```

## WaitGroup: Synchronizing Goroutines

The `sync` package provides `WaitGroup` to wait for goroutines to finish:

```go
import "sync"

var wg = sync.WaitGroup{}

func main() {
    wg.Add(1)  // Tell WaitGroup to expect 1 goroutine
    go sendEmail()
    
    wg.Wait()  // Block until counter is 0
    fmt.Println("All done")
}

func sendEmail() {
    // do work...
    wg.Done()  // Decrement counter by 1
}
```

### WaitGroup Methods

| Method | Description |
|--------|-------------|
| `Add(n)` | Increases counter by n (number of goroutines to wait for) |
| `Wait()` | Blocks until counter is 0 |
| `Done()` | Decrements counter by 1 (call at end of goroutine) |

## Practical Example

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

var wg = sync.WaitGroup{}

func main() {
    wg.Add(1)
    go sendTicket(2, "Shubham", "Singh", "shubham@example.com")
    
    fmt.Println("Continuing with other work...")
    
    wg.Wait()
    fmt.Println("All tickets sent!")
}

func sendTicket(userTickets uint, firstName string, lastName string, emailAddress string) {
    time.Sleep(10 * time.Second)
    var ticket = fmt.Sprintf("%v tickets for %v %v", userTickets, firstName, lastName)
    fmt.Printf("\n--------------------------------------------------------\n")
    fmt.Printf("Sending ticket %v \nto email address %v\n", ticket, emailAddress)
    fmt.Printf("--------------------------------------------------------\n")
    wg.Done()
}
```

## What Makes Go Different?

### Green Threads

Go uses "Green Threads" - an abstraction of actual threads:
- Managed by the Go runtime, not the OS
- Much cheaper and lighter than OS threads
- You can run hundreds of thousands or millions of goroutines without affecting performance

### Channels

Built-in functionality for goroutines to communicate with each other (covered in advanced topics).

## Go Routines vs OS Threads

| Aspect | Go Routines | OS Threads |
|--------|-------------|------------|
| Managed by | Go runtime | Kernel |
| Hardware dependent | No | Yes |
| Resource cost | Very low | Higher |
| Startup time | Fast | Slower |
| Communication | Channels (easy) | Complex |
| Scalability | Millions possible | Limited by resources |

## Key Points

- A Go function can return multiple values
- Use `go` keyword to run a function as a goroutine
- Use `sync.WaitGroup` to synchronize goroutines
- Goroutines are extremely lightweight compared to traditional threads
